use axum::{extract::{Path, Query, State}, http::StatusCode, response::IntoResponse, Json};
use serde::{Deserialize, Serialize};

use crate::{book::{save_books_to_csv, Book}, AppState};


/// Represents parameters for searching books.
/// `title` is an optional field to filter books by title.
#[derive(Debug, Deserialize)]
pub struct SearchParams {
    pub title: Option<String>,
}

/// Represents the data required to create or update a book.
/// Does not include the `id` as it's generated by the server.
#[derive(Debug, Deserialize, Serialize)]
pub struct CreateBook {
    pub title: Option<String>,
    pub author: Option<String>,
}

pub async fn list_books(
    State(books): AppState
) -> Json<Option<Vec<Book>>> {
    let shared_books = books.read().unwrap().clone();
    Json(Some(shared_books))
}

pub async fn get_book(
    Path(id): Path<u32>, 
    State(books): AppState
) -> impl IntoResponse {
    let shared_books = books.read().unwrap().clone();

    if let Some(book) = shared_books.iter().find(|b| b.id == id) {
        Json(book).into_response()
    } else {
        (StatusCode::NOT_FOUND, "Book not found").into_response()
    }
}

pub async fn add_book(
    State(books): AppState, 
    Json(new_book): Json<CreateBook>
) -> impl IntoResponse {
    if new_book.title.is_none() || new_book.author.is_none() {
        return (StatusCode::BAD_REQUEST, "Title and author are required").into_response();
    }

    let mut books_writer = books.write().unwrap();
    let next_id = books_writer.iter().map(|book|  book.id).max().unwrap_or(0) + 1;

    let book = Book {
        id: next_id,
        title: new_book.title.unwrap(),
        author: new_book.author.unwrap(),
    };

    books_writer.push(book.clone());
    save_books_to_csv(&books_writer).unwrap();
    (StatusCode::CREATED, Json(book)).into_response()
}

pub async fn update_book(
    Path(id): Path<u32>,
    State(books): AppState,
    Json(updated_book): Json<CreateBook>
) -> impl IntoResponse {
    if updated_book.title.is_none() || updated_book.author.is_none() {
        return (StatusCode::BAD_REQUEST, "Title and author are required");
    }

    let mut books_writer = books.write().unwrap();
    let mut found = false;

    for book in books_writer.iter_mut() {
        if book.id == id {
            book.title = updated_book.title.unwrap();
            book.author = updated_book.author.unwrap();
            found = true;
            break;
        }
    }

    if found {
        save_books_to_csv(&books_writer).unwrap();
        return (StatusCode::OK, "Book Updated successfully");
    } 

    (StatusCode::NOT_FOUND, "Book not found")
}

pub async fn delete_book(
    Path(id): Path<u32>, 
    State(books): AppState
) -> impl IntoResponse {
    let mut books_writer = books.write().unwrap();
    let book_count = books_writer.len();

    books_writer.retain(|book| book.id != id);

    if books_writer.len() < book_count {
        save_books_to_csv(&books_writer).unwrap();
        return (StatusCode::OK, "Book deleted successfully");
    }

    (StatusCode::NOT_FOUND, "Book not found")

}

pub async fn search_books(Query(params): Query<SearchParams>, State(books): AppState) -> Json<Vec<Book>> {
    let books_reader = books.read().unwrap();
    let filtered_books = books_reader.iter()
    .filter(|book| {
        if let Some(title) = &params.title {
            book.title.to_lowercase().contains(title.to_lowercase().as_str())
        } else {
            true
        }
    })
    .cloned().collect();
    Json(filtered_books)
}

