use axum::{extract::{Path, Query, State}, http::StatusCode, response::IntoResponse, Json};
use serde::{Deserialize, Serialize};
use sqlx::{Pool, Postgres};

use crate::book::{self, add_book, delete_book, get_books_list, search_books, update_book, Book };


/// Represents parameters for searching books.
/// `title` is an optional field to filter books by title.
#[derive(Debug, Deserialize)]
pub struct SearchParams {
    pub title: Option<String>,
}

/// Represents the data required to create or update a book.
/// Does not include the `id` as it's generated by the server.
#[derive(Debug, Deserialize, Serialize)]
pub struct CreateBook {
    pub title: Option<String>,
    pub author: Option<String>,
}

pub async fn list_books_handler(
    State(connection): State<Pool<Postgres>>) -> impl IntoResponse {
    let book_list = get_books_list(&connection).await.map_err(|err| {
        eprintln!("Error fetching books: {}", err);
        (StatusCode::INTERNAL_SERVER_ERROR).into_response()
    });

    let books = match book_list {
        Ok(Some(books)) => {
            books
        },
        _ => {
            vec![]
        }
    };

    Json(books).into_response()
}

pub async fn get_book_handler(
    Path(id): Path<i32>, State(connection): State<Pool<Postgres>>) -> impl IntoResponse {
    
    let book_details = book::get_book_by_id(&connection, id).await.map_err(|err| {
        eprintln!("Error fetching books: {}", err);
        (StatusCode::INTERNAL_SERVER_ERROR).into_response()
    });

    match book_details {
        Ok(Some(book)) => {
            Json(book).into_response()
        },
        _ => {
            (StatusCode::NOT_FOUND, "Book not found").into_response()
        }
    }
}

// #[axum::debug_handler]
pub async fn add_book_handler(
    State(connection): State<Pool<Postgres>>,
    Json(new_book): Json<CreateBook>
)-> impl IntoResponse {
    if new_book.title.is_none() || new_book.author.is_none() {
        return (StatusCode::BAD_REQUEST, "Title and author are required").into_response();
    }

    let result = add_book(&connection, new_book.title.unwrap(), new_book.author.unwrap()).await;

    match result {
        Ok(_) => {
            StatusCode::CREATED.into_response()
        },
        Err(err) => {
            eprintln!("Error adding book: {}", err);
            StatusCode::INTERNAL_SERVER_ERROR.into_response()
        }
    }
}

#[axum::debug_handler]
pub async fn update_book_handler(
    Path(id): Path<i32>,
    State(connection): State<Pool<Postgres>>,
    Json(updated_book): Json<CreateBook>
) -> impl IntoResponse {
    if updated_book.title.is_none() || updated_book.author.is_none() {
        return (StatusCode::BAD_REQUEST, "Title and author are required").into_response();
    }

    let result = update_book(&connection, Book {
        id,
        title: updated_book.title.unwrap(),
        author: updated_book.author.unwrap(),
    }).await;

    match result {
        Ok(_) => {
            StatusCode::OK.into_response()
        },
        Err(err) => {
            eprintln!("Error updating book: {}", err);
            StatusCode::INTERNAL_SERVER_ERROR.into_response()
        }
    }
}

pub async fn delete_book_handler(
    Path(id): Path<i32>, 
    State(connection): State<Pool<Postgres>>
) -> StatusCode {
    match delete_book(&connection, id).await {
        Ok(_) => {
            StatusCode::NO_CONTENT
        },
        Err(err) => {
            eprintln!("Error deleting book: {}", err);
            StatusCode::INTERNAL_SERVER_ERROR
        }
    }

}

pub async fn search_books_handler(Query(params): Query<SearchParams>, State(connection): State<Pool<Postgres>>) -> Json<Vec<Book>> {
    let search_term = params.title;

    match search_books(&connection, search_term).await {
        Ok(books) => {
            return Json(books);
        },
        Err(err) => {
            eprintln!("Error searching books: {}", err);
            return Json(vec![]);
        }
    }
}

